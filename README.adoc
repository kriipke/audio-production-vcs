= Audio Version Control (A-VCS) — Spec v0.1.0
:toc:
:toclevels: 3
:icons: font
:sectanchors:
:sectnums:

A clean, producer-friendly “audio VCS” from *writing → post → mastering*. It keeps the exact naming logic, makes edge-cases explicit, and adds just enough structure (folders, manifests, symlinks) so collaborators and future-you can glance and know what’s what.


== Overview

This Specification defines a versioning system for music production projects akin to https://semver.org[semantic versioning] for source code repositories. The specification acknowledges the following steps common to many music production workflows:

1 DAW:: This work is creative work being done craft a track and often involves a mix of midi a sample-based workflows to arrange and produce the tracks that comprise a finished song. Work done in DAWs is typically saved as DAW project files for exmpaple `als` for Ableton, however others such as Logic and FL Studio use their proprietary extensions.
input::: `als` project file
output::: audio stems (multiple)
2 Post-Processing:: For the sake of this specification it is assumed that post-processing is performed on __audio stems__. Often this work is done iteratively such that multiple "versions" of the stems will be bounced down each modify the tracks that comprise the song a bit more each time. Once the tracks have been crafted to everyones liking and the ratios between all the elements are appropriate the stems are all bounced down into a singe track containing the primary bus used to mix the track to produce the __unmastered track__.
input::: audio stems (multiple)
output::: unmastered track (single track)
3 Mastering:: Once the unmastered track is ready for processing on the master track it begins the mastering phase of the process and the single unmastered track is processed as one does during the mastering process. Once the mastered track is ready is returned to the artist for revisions should there be any. Any subsequent tweaks produce a new "version" of the master. The version that is agreed upon to be published is usually referred to as the "final master".
input::: unmastered track (single track)
output::: mastered track (single track)

=== Stages of Production

==== __Production__
```
[DAW Save] --> [Bounce]
```

==== __Post-Production__
```
[DAW Save] --> [Stems] --> [Unmastered] --> [Masters]
```

== Vocabulary & Tokens

TRACK:: constant, all-caps, words separated by `_` only: `[A-Z0-9_]+`
T1:: 12-hour, zero-padded 4-digit time, plus `A|P` (AM/PM): `HHMM\[A|P]`
Examples::: `0007A`, `0942P`, `1200A`, `1200P`
T2:: a second time token, same format, used for post-production stem bounces
STEM:: controlled vocabulary (suggested): `BASS|DRUMS|KICK|SNARE|PERC|VOCALS|BGV|SYNTH|PIANO|GTR|FX|PAD|LEAD|SUB|ROOM|BUS_<NAME>`. Extend if needed but keep to `\[A-Z0-9_]+`.
IDX:: mastering index: integer `1..n` or the literal `FINAL`
EXT:: file extension: `.als`, `.wav`, `.mp3`

== Naming Grammar (Formal)

Write-phase snapshots (Ableton save + bounces):

[source,text]
----
<TRACK>-<T1>.als
<TRACK>-<T1>.wav
<TRACK>-<T1>.mp3
----

Post-production stems (Pro Tools, etc):

[source,text]
----
<TRACK>-<T1>-<T2>-<STEM>.wav
----

Unmastered stereo (render from post session using that stem set):

[source,text]
----
<TRACK>-<T1>-<T2>-[unmastered].wav
----

Master candidates (in-house):

[source,text]
----
<TRACK>-<T1>-<T2>-<IDX>.wav         ; IDX = 1,2,3,...
<TRACK>-<T1>-<T2>-FINAL.wav         ; duplicate of the chosen IDX
----

== Examples

[source,text]
----
ABLETON save + bounces:
TRACK_TITLE-1200A.als
TRACK_TITLE-1200A.wav
TRACK_TITLE-1200A.mp3

Post stems from that save at 12:30 AM:
TRACK_TITLE-1200A-1230A-BASS.wav
TRACK_TITLE-1200A-1230A-DRUMS.wav
TRACK_TITLE-1200A-1230A-VOCALS.wav

Unmastered from that post:
TRACK_TITLE-1200A-1230A-[unmastered].wav

Mastering passes:
TRACK_TITLE-1200A-1230A-1.wav
TRACK_TITLE-1200A-1230A-2.wav
TRACK_TITLE-1200A-1230A-FINAL.wav    (if #2 chosen)
----

== Canonical Folder Layout

[source,text]
----
PROJECTS/
└── <TRACK>/
├── ableton/                 # .als snapshots + primary bounces
│   ├── <TRACK>-<T1>.als
│   ├── <TRACK>-<T1>.wav
│   └── <TRACK>-<T1>.mp3
├── stems/                   # grouped per (T1,T2) bounce set
│   └── <T1>-<T2>/
│       ├── <TRACK>-<T1>-<T2>-BASS.wav
│       └── <TRACK>-<T1>-<T2>-DRUMS.wav
├── post/                    # DAW session for post (e.g., PTX)
│   └── <T1>-<T2>/
│       ├── session.ptx
│       └── prints/          # (optional) printed buses, refs
├── mixes/
│   ├── <TRACK>-<T1>-<T2>-[unmastered].wav
│   └── refs/                # comparators / references
├── masters/
│   ├── <TRACK>-<T1>-<T2>-1.wav
│   ├── <TRACK>-<T1>-<T2>-2.wav
│   └── <TRACK>-<T1>-<T2>-FINAL.wav
├── manifests/               # JSON/YAML entries per version event
│   └── <ISO8601>_<event>.json
└── symlinks/                # fast pointers
├── LATEST_ALS -> ../ableton/<TRACK>-<T1>.als
├── LATEST_BOUNCE -> ../ableton/<TRACK>-<T1>.wav
├── LATEST_STEMS -> ../stems/<T1>-<T2>/
├── LATEST_UNMASTERED -> ../mixes/<TRACK>-<T1>-<T2>-\[unmastered].wav
└── FINAL -> ../masters/<TRACK>-<T1>-<T2>-FINAL.wav
----


== Workflow (State Machine)

. *Write (Ableton)*
.. On every meaningful save: save `.als` using `<TRACK>-<T1>.als`.
.. Render a full-length WAV with *exactly* the same base name and make a 320 kbps MP3 (for quick A/B and mobile checks).
.. Update `symlinks/LATEST_ALS` and `symlinks/LATEST_BOUNCE`.

. *Post (Pro Tools or similar)*
.. Stem out from the chosen Ableton snapshot `<T1>` and name stems with a fresh `<T2>`:
`<TRACK>-<T1>-<T2>-<STEM>.wav` into `stems/<T1>-<T2>/`.
.. Create a post session folder `post/<T1>-<T2>/` and work from those stems.
.. When ready, print the *unmastered* stereo to `mixes/<TRACK>-<T1>-<T2>-[unmastered].wav`.
.. Update `symlinks/LATEST_STEMS` and `symlinks/LATEST_UNMASTERED`.

. *Mastering*
.. Each candidate render increments `IDX`:
`masters/<TRACK>-<T1>-<T2>-1.wav`, then `…-2.wav`, etc.
.. When one is chosen, duplicate to `…-FINAL.wav` and update `symlinks/FINAL`.

== Conventions & Guardrails

* *Characters*: `\[A-Z0-9_]` only (safe across OS and S3/object storage).
* *MP3s*: always 320 kbps CBR unless noted otherwise.
* *Time zones*: manifests should use offsetted ISO-8601; filenames stick to `A|P` (human-fast).
* *Stem vocab*: keep consistent. If routing changes, document in the manifest (`routing_map`).
* *No overwrite*: all new outputs create new files. Symlinks provide the “latest”.

